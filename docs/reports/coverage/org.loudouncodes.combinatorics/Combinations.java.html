<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Combinations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">loudouncodes-combinatorics</a> &gt; <a href="index.source.html" class="el_package">org.loudouncodes.combinatorics</a> &gt; <span class="el_source">Combinations.java</span></div><h1>Combinations.java</h1><pre class="source lang-java linenums">package org.loudouncodes.combinatorics;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Combinations â€” k-subsets of {0,1,...,n-1}, with an opt-in flag for repetition.
 *
 * &lt;p&gt;Fluent usage:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;No repetition (default): {@code Combinations.of(n).choose(k)}
 *   &lt;li&gt;With repetition: {@code Combinations.of(n).withRepetition().choose(k)}
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Order is lexicographic in both modes. Returned arrays are fresh defensive copies. Iterators
 * obey the contract: {@code hasNext()} becomes false at exhaustion and {@code next()} then throws
 * {@link java.util.NoSuchElementException}.
 */
public final class Combinations {

  private Combinations() {
    /* no instances */
  }

  /**
   * Entry point for combinations over the ground set {@code {0,1,...,n-1}}.
   *
   * @param n ground-set size (must be {@code &gt;= 0})
   * @return an immutable specification for building combination iterables
   * @throws IllegalArgumentException if {@code n &lt; 0}
   */
  public static Spec of(int n) {
<span class="fc bfc" id="L36" title="All 2 branches covered.">    if (n &lt; 0) throw new IllegalArgumentException(&quot;n must be non-negative&quot;);</span>
<span class="fc" id="L37">    return new Spec(n, false); // default: without repetition</span>
  }

  /** Fluent spec for combinations. Immutable value object. */
  public static final class Spec {
    private final int n;
    private final boolean repetition;

<span class="fc" id="L45">    private Spec(int n, boolean repetition) {</span>
<span class="fc" id="L46">      this.n = n;</span>
<span class="fc" id="L47">      this.repetition = repetition;</span>
<span class="fc" id="L48">    }</span>

    /**
     * Enable combinations with repetition (multiset combinations).
     *
     * @return a new {@code Spec} with repetition enabled
     */
    public Spec withRepetition() {
<span class="fc" id="L56">      return new Spec(n, true);</span>
    }

    /**
     * Explicitly disable repetition (regular combinations).
     *
     * @return a new {@code Spec} with repetition disabled
     */
    public Spec withoutRepetition() {
<span class="nc" id="L65">      return new Spec(n, false);</span>
    }

    /**
     * Terminal: enumerate all size-{@code k} combinations in lexicographic order.
     *
     * &lt;p&gt;When repetition is disabled (default), this yields the usual k-combinations (no repeats)
     * and requires {@code 0 &lt;= k &lt;= n}. When repetition is enabled via {@link #withRepetition()},
     * this yields multiset combinations (nondecreasing k-tuples), where {@code k &gt;= 0} and {@code
     * n} may be smaller than {@code k}.
     *
     * @param k subset size (must be {@code &gt;= 0}; and if repetition is disabled, {@code k &lt;= n})
     * @return a sized iterable view yielding defensive copies in lexicographic order
     * @throws IllegalArgumentException if arguments are invalid
     */
    public KChoose choose(int k) {
<span class="fc bfc" id="L81" title="All 2 branches covered.">      if (k &lt; 0) throw new IllegalArgumentException(&quot;k must be non-negative&quot;);</span>
<span class="fc bfc" id="L82" title="All 4 branches covered.">      if (!repetition &amp;&amp; k &gt; n) {</span>
<span class="fc" id="L83">        throw new IllegalArgumentException(&quot;k must be \u2264 n when repetition is disabled&quot;);</span>
      }
<span class="fc" id="L85">      return new KChoose(n, k, repetition);</span>
    }
  }

  /**
   * Sized iterable view over k-combinations (with or without repetition).
   *
   * &lt;p&gt;Implements {@link Iterable} so it drops into enhanced-for loops, and adds {@link #size()}
   * and {@link #sizeExact()} for counts.
   */
  public static final class KChoose implements Iterable&lt;int[]&gt; {
    private final int n, k;
    private final boolean repetition;

<span class="fc" id="L99">    KChoose(int n, int k, boolean repetition) {</span>
<span class="fc" id="L100">      this.n = n;</span>
<span class="fc" id="L101">      this.k = k;</span>
<span class="fc" id="L102">      this.repetition = repetition;</span>
<span class="fc" id="L103">    }</span>

    /**
     * Number of combinations in this view.
     *
     * &lt;p&gt;No repetition: {@code C(n,k)}. With repetition: {@code C(n+k-1, k)}. This returns a {@code
     * long} and may overflow for very large inputs; for exact counts use {@link #sizeExact()}.
     *
     * @return the number of combinations (best-effort {@code long})
     */
    public long size() {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">      if (k == 0) return 1L;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">      if (!repetition) {</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (k &gt; n) return 0L; // defensive</span>
<span class="fc" id="L117">        return binomLong(n, k);</span>
      } else {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (n == 0) return 0L; // except k==0 handled above</span>
<span class="fc" id="L120">        return binomLong(n + k - 1, k);</span>
      }
    }

    /**
     * Exact number of combinations as a {@link BigInteger}.
     *
     * @return exact count ({@code C(n,k)} or {@code C(n+k-1,k)})
     */
    public BigInteger sizeExact() {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">      if (k == 0) return BigInteger.ONE;</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">      if (!repetition) {</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (k &gt; n) return BigInteger.ZERO;</span>
<span class="fc" id="L133">        return binomBig(n, k);</span>
      } else {
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (n == 0) return BigInteger.ZERO;</span>
<span class="fc" id="L136">        return binomBig(n + k - 1, k);</span>
      }
    }

    @Override
    public Iterator&lt;int[]&gt; iterator() {
<span class="fc bfc" id="L142" title="All 2 branches covered.">      return repetition ? new WithRepIt(n, k) : new NoRepIt(n, k);</span>
    }
  }

  // ---------------------------------------------------------------------------
  // Iterator for combinations WITHOUT repetition (lex order).
  //
  // State 'c' always holds the NEXT combination to return.
  // After emitting 'c', we advance it; if no successor exists, set c = null.
  //
  // First combination (k &gt; 0): [0,1,2,...,k-1]
  // Successor rule: find rightmost i with c[i] &lt; n - k + i; increment c[i];
  //                 then for j &gt; i, set c[j] = c[j - 1] + 1.
  // k == 0: single empty combination.
  // ---------------------------------------------------------------------------
  private static final class NoRepIt implements Iterator&lt;int[]&gt; {
    private final int n, k;
    private int[] c; // null == exhausted

<span class="fc" id="L161">    NoRepIt(int n, int k) {</span>
<span class="fc" id="L162">      this.n = n;</span>
<span class="fc" id="L163">      this.k = k;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">      if (k == 0) {</span>
<span class="fc" id="L165">        this.c = new int[0];</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">      } else if (k &gt; n) {</span>
        // Should be prevented by validation, but keep iterator robust.
<span class="nc" id="L168">        this.c = null;</span>
      } else {
<span class="fc" id="L170">        this.c = new int[k];</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (int i = 0; i &lt; k; i++) c[i] = i;</span>
      }
<span class="fc" id="L173">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L177" title="All 2 branches covered.">      return c != null;</span>
    }

    @Override
    public int[] next() {
<span class="fc bfc" id="L182" title="All 2 branches covered.">      if (c == null) throw new NoSuchElementException(&quot;Combinations exhausted&quot;);</span>
<span class="fc" id="L183">      int[] out = Arrays.copyOf(c, k); // defensive copy</span>

      // advance to next combination
<span class="fc bfc" id="L186" title="All 2 branches covered.">      if (k == 0) {</span>
<span class="fc" id="L187">        c = null; // only one empty combination</span>
<span class="fc" id="L188">        return out;</span>
      }
<span class="fc" id="L190">      int i = k - 1;</span>
<span class="fc bfc" id="L191" title="All 4 branches covered.">      while (i &gt;= 0 &amp;&amp; c[i] == n - k + i) i--;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">      if (i &lt; 0) {</span>
<span class="fc" id="L193">        c = null; // last one was just returned</span>
      } else {
<span class="fc" id="L195">        c[i]++;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        for (int j = i + 1; j &lt; k; j++) c[j] = c[j - 1] + 1;</span>
      }
<span class="fc" id="L198">      return out;</span>
    }
  }

  // ---------------------------------------------------------------------------
  // Iterator for combinations WITH repetition (multichoose, lex order).
  //
  // Represent each multiset as a nondecreasing k-tuple 'a' with values in 0..n-1.
  // State 'a' always holds the NEXT tuple to return.
  // After emitting 'a', we advance it; if no successor exists, set a = null.
  //
  // First (k &gt; 0): [0,0,...,0]
  // Successor: find rightmost i with a[i] &lt; n - 1; increment a[i]; set all j&gt;i to a[i].
  // Edge cases:
  //   - k == 0: single empty combination.
  //   - n == 0 &amp;&amp; k &gt; 0: no combinations (a = null).
  // ---------------------------------------------------------------------------
  private static final class WithRepIt implements Iterator&lt;int[]&gt; {
    private final int n, k;
    private int[] a; // null == exhausted

<span class="fc" id="L219">    WithRepIt(int n, int k) {</span>
<span class="fc" id="L220">      this.n = n;</span>
<span class="fc" id="L221">      this.k = k;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">      if (k == 0) {</span>
<span class="fc" id="L223">        this.a = new int[0];</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">      } else if (n == 0) {</span>
<span class="fc" id="L225">        this.a = null; // no elements to choose from, except when k==0 handled above</span>
      } else {
<span class="fc" id="L227">        this.a = new int[k]; // all zeros to start</span>
      }
<span class="fc" id="L229">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L233" title="All 2 branches covered.">      return a != null;</span>
    }

    @Override
    public int[] next() {
<span class="fc bfc" id="L238" title="All 2 branches covered.">      if (a == null) throw new NoSuchElementException(&quot;Combinations-with-repetition exhausted&quot;);</span>
<span class="fc" id="L239">      int[] out = Arrays.copyOf(a, k); // defensive copy</span>

      // advance to next multiset (nondecreasing tuple)
<span class="fc bfc" id="L242" title="All 2 branches covered.">      if (k == 0) {</span>
<span class="fc" id="L243">        a = null; // only one empty combination</span>
<span class="fc" id="L244">        return out;</span>
      }
<span class="fc" id="L246">      int i = k - 1;</span>
<span class="fc bfc" id="L247" title="All 4 branches covered.">      while (i &gt;= 0 &amp;&amp; a[i] == n - 1) i--;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">      if (i &lt; 0) {</span>
<span class="fc" id="L249">        a = null; // last one was just returned</span>
      } else {
<span class="fc" id="L251">        a[i]++;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (int j = i + 1; j &lt; k; j++) a[j] = a[i];</span>
      }
<span class="fc" id="L254">      return out;</span>
    }
  }

  // ---------------------------------------------------------------------------
  // Binomial helpers (long &amp; BigInteger) with reduction to limit overflow.
  // ---------------------------------------------------------------------------

  private static long binomLong(int n, int k) {
<span class="pc bpc" id="L263" title="2 of 4 branches missed.">    if (k &lt; 0 || k &gt; n) return 0L;</span>
<span class="fc" id="L264">    k = Math.min(k, n - k);</span>
<span class="fc" id="L265">    long res = 1L;</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">    for (int i = 1; i &lt;= k; i++) {</span>
<span class="fc" id="L267">      long num = n - (k - i); // n-k+1, n-k+2, ..., n</span>
<span class="fc" id="L268">      long den = i;</span>
<span class="fc" id="L269">      long g = gcd(num, den);</span>
<span class="fc" id="L270">      num /= g;</span>
<span class="fc" id="L271">      den /= g;</span>

      // reduce denominator against current result if possible
<span class="fc" id="L274">      long g2 = gcd(res, den);</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">      if (g2 &gt; 1) {</span>
<span class="fc" id="L276">        res /= g2;</span>
<span class="fc" id="L277">        den /= g2;</span>
      }

      // multiply (may still overflow for very large results; acceptable for classroom sizes)
<span class="fc" id="L281">      res *= num;</span>

      // by construction, den should now be 1
    }
<span class="fc" id="L285">    return res;</span>
  }

  private static BigInteger binomBig(int n, int k) {
<span class="pc bpc" id="L289" title="2 of 4 branches missed.">    if (k &lt; 0 || k &gt; n) return BigInteger.ZERO;</span>
<span class="fc" id="L290">    k = Math.min(k, n - k);</span>
<span class="fc" id="L291">    BigInteger res = BigInteger.ONE;</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">    for (int i = 1; i &lt;= k; i++) {</span>
<span class="fc" id="L293">      int num = n - (k - i);</span>
<span class="fc" id="L294">      int den = i;</span>
<span class="fc" id="L295">      int g = (int) gcd(num, den);</span>
<span class="fc" id="L296">      num /= g;</span>
<span class="fc" id="L297">      den /= g;</span>

      // reduce denominator against res if possible (exact division)
<span class="fc" id="L300">      BigInteger denBI = BigInteger.valueOf(den);</span>
<span class="fc" id="L301">      BigInteger[] div = res.divideAndRemainder(denBI);</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">      if (div[1].equals(BigInteger.ZERO)) {</span>
<span class="fc" id="L303">        res = div[0];</span>
<span class="fc" id="L304">        den = 1;</span>
      }

<span class="fc" id="L307">      res = res.multiply(BigInteger.valueOf(num));</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">      if (den != 1) {</span>
<span class="nc" id="L309">        res = res.divide(BigInteger.valueOf(den)); // exact</span>
      }
    }
<span class="fc" id="L312">    return res;</span>
  }

  private static long gcd(long a, long b) {
<span class="fc" id="L316">    a = Math.abs(a);</span>
<span class="fc" id="L317">    b = Math.abs(b);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">    while (b != 0) {</span>
<span class="fc" id="L319">      long t = a % b;</span>
<span class="fc" id="L320">      a = b;</span>
<span class="fc" id="L321">      b = t;</span>
<span class="fc" id="L322">    }</span>
<span class="fc" id="L323">    return a;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>