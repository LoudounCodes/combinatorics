<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CartesianProduct.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">loudouncodes-combinatorics</a> &gt; <a href="index.source.html" class="el_package">org.loudouncodes.combinatorics</a> &gt; <span class="el_source">CartesianProduct.java</span></div><h1>CartesianProduct.java</h1><pre class="source lang-java linenums">package org.loudouncodes.combinatorics;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;

/**
 * Fluent API for generating tuples from a mixed-radix Cartesian product.
 *
 * &lt;p&gt;Given non-negative dimensions {@code d[0], d[1], ..., d[m-1]}, this iterable yields every
 * {@code m}-length tuple {@code t} such that {@code 0 &lt;= t[i] &lt; d[i]} for each coordinate.
 *
 * &lt;h2&gt;Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // 3 attributes, each with 3 values (e.g., a SET card): 3^3 = 27 tuples
 * for (int[] t : CartesianProduct.of(3, 3, 3)) {
 *   System.out.println(Arrays.toString(t));
 * }
 *
 * // Combine with IndexingAdapter to map indices to real objects per coordinate:
 * // Suppose suits = [&quot;♠&quot;,&quot;♥&quot;], ranks = [&quot;A&quot;,&quot;K&quot;,&quot;Q&quot;], colors = [&quot;Black&quot;,&quot;Red&quot;]
 * // Then dims = [suits.size(), ranks.size(), colors.size()] = [2,3,2]
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Order of generation&lt;/h2&gt;
 *
 * &lt;p&gt;Lexicographic with the &lt;em&gt;rightmost&lt;/em&gt; coordinate varying fastest (odometer behavior).
 * Start at {@code [0,0,...,0]}, then repeatedly increment the last position; on overflow, carry
 * left and reset trailing positions to 0.
 *
 * &lt;h2&gt;Counting&lt;/h2&gt;
 *
 * &lt;p&gt;Total tuples = {@code Π dims[i]}.
 *
 * &lt;h2&gt;Edge cases&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;No dimensions (i.e., {@code of()}): one empty tuple {@code []}.
 *   &lt;li&gt;If any dimension is zero and there is at least one dimension, the product is empty.
 *   &lt;li&gt;Negative dimensions are rejected with {@link IllegalArgumentException}.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Implementation note:&lt;/strong&gt; Each {@link java.util.Iterator#next() Iterator.next()}
 * returns a defensive copy to protect the iterator's state.
 *
 * @since 0.2.0
 */
public final class CartesianProduct {

  private CartesianProduct() {}

  /**
   * Creates an iterable over the Cartesian product of the given non-negative dimensions.
   *
   * @param dims non-null array of dimensions; each {@code dims[i] &gt;= 0}
   * @return a sized iterable over all tuples
   * @throws NullPointerException if {@code dims} is null
   * @throws IllegalArgumentException if any dimension is negative
   */
  public static Product of(int... dims) {
<span class="fc" id="L64">    Objects.requireNonNull(dims, &quot;dims&quot;);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">    for (int d : dims) {</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">      if (d &lt; 0) throw new IllegalArgumentException(&quot;All dimensions must be &gt;= 0, got &quot; + d);</span>
    }
    // Defensive copy so future external changes to the passed array don't affect us
<span class="fc" id="L69">    int[] copy = Arrays.copyOf(dims, dims.length);</span>
<span class="fc" id="L70">    return new Product(copy);</span>
  }

  /**
   * Iterable view of the Cartesian product for fixed dimensions. Provides {@link #size()} and
   * supports enhanced-for iteration.
   */
  public static final class Product implements Iterable&lt;int[]&gt; {
    private final int[] dims;

<span class="fc" id="L80">    private Product(int[] dims) {</span>
<span class="fc" id="L81">      this.dims = dims;</span>
<span class="fc" id="L82">    }</span>

    /**
     * Number of tuples = product of dimensions. Returns 0 if any dimension is 0 (and there is at
     * least one dimension). If there are no dimensions, returns 1 (the empty tuple).
     *
     * &lt;p&gt;Note: This may overflow for large inputs; intended for classroom-scale values.
     *
     * @return the number of tuples in this Cartesian product
     */
    public long size() {
<span class="fc bfc" id="L93" title="All 2 branches covered.">      if (dims.length == 0) return 1L;</span>
<span class="fc" id="L94">      long prod = 1L;</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">      for (int d : dims) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (d == 0) return 0L;</span>
<span class="fc" id="L97">        prod *= d;</span>
      }
<span class="fc" id="L99">      return prod;</span>
    }

    /**
     * Exact number of tuples = product of dimensions.
     *
     * @return exact count as a {@link BigInteger}
     */
    public BigInteger sizeExact() {
<span class="fc bfc" id="L108" title="All 2 branches covered.">      if (dims.length == 0) return BigInteger.ONE;</span>
<span class="fc" id="L109">      BigInteger prod = BigInteger.ONE;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">      for (int d : dims) {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (d == 0) return BigInteger.ZERO;</span>
<span class="fc" id="L112">        prod = prod.multiply(BigInteger.valueOf(d));</span>
      }
<span class="fc" id="L114">      return prod;</span>
    }

    @Override
    public Iterator&lt;int[]&gt; iterator() {
<span class="fc" id="L119">      return new CartesianIterator(dims);</span>
    }
  }

  /**
   * Mixed-radix odometer iterator. State {@code cur} starts at all zeros and increments with
   * carries. Invariant: for each i, {@code 0 &lt;= cur[i] &lt; dims[i]}.
   */
  private static final class CartesianIterator implements Iterator&lt;int[]&gt; {
    private final int[] dims;
    private final int m; // number of coordinates
    private final int[] cur; // current tuple
    private boolean hasNext;

<span class="fc" id="L133">    CartesianIterator(int[] dims) {</span>
<span class="fc" id="L134">      this.dims = dims;</span>
<span class="fc" id="L135">      this.m = dims.length;</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">      if (m == 0) {</span>
        // Single empty tuple
<span class="fc" id="L139">        this.cur = new int[0];</span>
<span class="fc" id="L140">        this.hasNext = true;</span>
      } else {
        // If any dimension is 0 -&gt; empty product
<span class="fc" id="L143">        boolean empty = false;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for (int d : dims) {</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">          if (d == 0) {</span>
<span class="fc" id="L146">            empty = true;</span>
<span class="fc" id="L147">            break;</span>
          }
        }
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (empty) {</span>
<span class="fc" id="L151">          this.cur = new int[0];</span>
<span class="fc" id="L152">          this.hasNext = false;</span>
        } else {
<span class="fc" id="L154">          this.cur = new int[m];</span>
<span class="fc" id="L155">          Arrays.fill(this.cur, 0);</span>
<span class="fc" id="L156">          this.hasNext = true;</span>
        }
      }
<span class="fc" id="L159">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc" id="L163">      return hasNext;</span>
    }

    @Override
    public int[] next() {
<span class="fc bfc" id="L168" title="All 2 branches covered.">      if (!hasNext) throw new NoSuchElementException();</span>
<span class="fc" id="L169">      int[] out = cur.clone(); // defensive copy</span>
<span class="fc" id="L170">      advance();</span>
<span class="fc" id="L171">      return out;</span>
    }

    /** Increment the mixed-radix number in {@code cur} with bases {@code dims}. */
    private void advance() {
<span class="fc bfc" id="L176" title="All 2 branches covered.">      if (m == 0) { // emitted the single empty tuple</span>
<span class="fc" id="L177">        hasNext = false;</span>
<span class="fc" id="L178">        return;</span>
      }
<span class="fc bfc" id="L180" title="All 2 branches covered.">      for (int i = m - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L181">        cur[i]++;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (cur[i] &lt; dims[i]) {</span>
          // no carry; done
<span class="fc" id="L184">          return;</span>
        } else {
          // carry; reset this position and continue left
<span class="fc" id="L187">          cur[i] = 0;</span>
        }
      }
      // overflowed past the most significant digit -&gt; exhausted
<span class="fc" id="L191">      hasNext = false;</span>
<span class="fc" id="L192">    }</span>
  }

  /**
   * Demo entry point.
   *
   * @param args command-line arguments (unused)
   */
  public static void main(String[] args) {
<span class="nc" id="L201">    CartesianProduct.Product p = CartesianProduct.of(2, 3); // 2×3 = 6</span>
<span class="nc" id="L202">    System.out.println(&quot;size = &quot; + p.size());</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">    for (int[] t : p) {</span>
<span class="nc" id="L204">      System.out.println(Arrays.toString(t));</span>
<span class="nc" id="L205">    }</span>
<span class="nc" id="L206">    System.out.println(&quot;sizeExact = &quot; + p.sizeExact());</span>
<span class="nc" id="L207">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>