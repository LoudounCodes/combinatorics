<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BinaryGray.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">loudouncodes-combinatorics</a> &gt; <a href="index.source.html" class="el_package">org.loudouncodes.combinatorics</a> &gt; <span class="el_source">BinaryGray.java</span></div><h1>BinaryGray.java</h1><pre class="source lang-java linenums">package org.loudouncodes.combinatorics;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Binary Gray codes of length {@code n}.
 *
 * &lt;p&gt;Fluent entrypoint:
 *
 * &lt;pre&gt;{@code
 * // integers 0..(2^n-1) in reflected Gray order
 * for (int g : BinaryGray.of(3).asInts()) {
 *   // 0, 1, 3, 2, 6, 7, 5, 4
 * }
 *
 * // bit vectors (0/1) of length n, minimal-change order (one bit flips each step)
 * for (int[] bits : BinaryGray.of(3).asBits()) {
 *   // [0,0,0], [1,0,0], [1,1,0], [0,1,0], ...
 * }
 *
 * // subsets as sorted index lists
 * for (int[] S : BinaryGray.of(4).asSubsets()) {
 *   // [], [0], [0,1], [1], [1,2], [0,1,2], ...
 * }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;Views also available as {@code long}/{@link java.math.BigInteger BigInteger} bitmasks and as a
 * stream of minimal-change {@link BinaryGray.Toggle} events. All iterators return defensive copies
 * and obey the {@code hasNext()}/{@code next()} contract (exhaustion throws {@link
 * java.util.NoSuchElementException}).
 *
 * @since 0.3.0
 */
public final class BinaryGray {

  private BinaryGray() {}

  /**
   * Create a builder for Gray codes with {@code n} bits.
   *
   * @param n number of bits, must be {@code &gt;= 0}
   * @return a builder for {@code n}-bit Gray sequences
   * @throws IllegalArgumentException if {@code n &lt; 0}
   */
  public static Builder of(int n) {
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">    if (n &lt; 0) throw new IllegalArgumentException(&quot;n must be &gt;= 0&quot;);</span>
<span class="fc" id="L50">    return new Builder(n);</span>
  }

  /** Builder bound to {@code n} bits, offering multiple views of the same Gray sequence. */
  public static final class Builder {
    private final int n;

<span class="fc" id="L57">    private Builder(int n) {</span>
<span class="fc" id="L58">      this.n = n;</span>
<span class="fc" id="L59">    }</span>

    /**
     * Integers in reflected Gray order.
     *
     * &lt;p&gt;Each element is {@code g = i ^ (i &gt;&gt;&gt; 1)} for {@code i = 0..2^n-1}.
     *
     * @return iterable over {@code int} Gray codes
     * @throws IllegalArgumentException if {@code n &gt; 31} (does not fit in {@code int})
     */
    public AsInts asInts() {
<span class="fc bfc" id="L70" title="All 2 branches covered.">      if (n &gt; 31)</span>
<span class="fc" id="L71">        throw new IllegalArgumentException(</span>
            &quot;asInts() supports n up to 31; use asLongMasks() or asBigMasks()&quot;);
<span class="fc" id="L73">      return new AsInts(n);</span>
    }

    /**
     * Bit vectors (arrays of 0/1) of length {@code n} in minimal-change order.
     *
     * @return iterable over {@code int[]} bit vectors
     */
    public AsBits asBits() {
<span class="fc" id="L82">      return new AsBits(n);</span>
    }

    /**
     * Subsets represented as sorted index lists (ascending) in minimal-change order.
     *
     * @return iterable over {@code int[]} of selected indices
     */
    public AsSubsets asSubsets() {
<span class="fc" id="L91">      return new AsSubsets(n);</span>
    }

    /**
     * Gray codes as {@code long} bitmasks (bit i ↔ element i).
     *
     * &lt;p&gt;Note: see {@link BinaryGray.AsLongMasks#size()} and {@link
     * BinaryGray.AsLongMasks#sizeExact()} for count semantics.
     *
     * @return iterable over {@code long} Gray masks
     * @throws IllegalArgumentException if {@code n &gt; 62} (count does not fit in signed {@code
     *     long})
     */
    public AsLongMasks asLongMasks() {
<span class="fc bfc" id="L105" title="All 2 branches covered.">      if (n &gt; 62)</span>
<span class="fc" id="L106">        throw new IllegalArgumentException(</span>
            &quot;asLongMasks() supports n up to 62; use asBigMasks() for larger n&quot;);
<span class="fc" id="L108">      return new AsLongMasks(n);</span>
    }

    /**
     * Gray codes as {@link BigInteger} bitmasks (no size limit).
     *
     * @return iterable over {@link BigInteger} Gray masks
     */
    public AsBigMasks asBigMasks() {
<span class="fc" id="L117">      return new AsBigMasks(n);</span>
    }

    /**
     * Minimal-change delta stream. Each element indicates which bit flipped and its new value.
     *
     * &lt;p&gt;Emits {@code 2^n - 1} toggles (there are that many steps between {@code 2^n} states).
     *
     * @return iterable over {@link Toggle} events
     */
    public AsToggles asToggles() {
<span class="fc" id="L128">      return new AsToggles(n);</span>
    }
  }

  // ----------------------------------------------------------------------------------------------
  // Public views
  // ----------------------------------------------------------------------------------------------

  /** Iterable over {@code int} Gray codes, {@code n &lt;= 31}. */
  public static final class AsInts implements Iterable&lt;Integer&gt; {
    private final int n;

<span class="fc" id="L140">    private AsInts(int n) {</span>
<span class="fc" id="L141">      this.n = n;</span>
<span class="fc" id="L142">    }</span>

    /**
     * Returns the number of elements in the sequence.
     *
     * @return {@code 2^n} (fits in {@code long} for {@code n &lt;= 62})
     */
    public long size() {
<span class="fc" id="L150">      return 1L &lt;&lt; n; // n &lt;= 31 here, so safe</span>
    }

    /**
     * Returns the exact number of elements in the sequence.
     *
     * @return {@code 2^n}
     */
    public BigInteger sizeExact() {
<span class="fc" id="L159">      return BigInteger.ONE.shiftLeft(n);</span>
    }

    @Override
    public Iterator&lt;Integer&gt; iterator() {
<span class="fc" id="L164">      return new IntsIt(n);</span>
    }
  }

  /** Iterable over bit vectors (arrays of 0/1), minimal-change order, any {@code n &gt;= 0}. */
  public static final class AsBits implements Iterable&lt;int[]&gt; {
    private final int n;

<span class="fc" id="L172">    private AsBits(int n) {</span>
<span class="fc" id="L173">      this.n = n;</span>
<span class="fc" id="L174">    }</span>

    /**
     * Returns the (possibly saturated) number of elements in the sequence.
     *
     * @return {@code 2^n}, or {@code Long.MAX_VALUE} if the exact value exceeds {@code long}
     */
    public long size() {
<span class="nc" id="L182">      BigInteger s = sizeExact();</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      return s.bitLength() &lt;= 63 ? s.longValue() : Long.MAX_VALUE;</span>
    }

    /**
     * Returns the exact number of elements in the sequence.
     *
     * @return {@code 2^n}
     */
    public BigInteger sizeExact() {
<span class="nc" id="L192">      return BigInteger.ONE.shiftLeft(n);</span>
    }

    @Override
    public Iterator&lt;int[]&gt; iterator() {
<span class="fc" id="L197">      return new BitsIt(n);</span>
    }
  }

  /** Iterable over subsets as sorted index arrays, minimal-change order, any {@code n &gt;= 0}. */
  public static final class AsSubsets implements Iterable&lt;int[]&gt; {
    private final int n;

<span class="fc" id="L205">    private AsSubsets(int n) {</span>
<span class="fc" id="L206">      this.n = n;</span>
<span class="fc" id="L207">    }</span>

    /**
     * Returns the (possibly saturated) number of subsets.
     *
     * @return {@code 2^n}, or {@code Long.MAX_VALUE} if the exact value exceeds {@code long}
     */
    public long size() {
<span class="nc" id="L215">      BigInteger s = sizeExact();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">      return s.bitLength() &lt;= 63 ? s.longValue() : Long.MAX_VALUE;</span>
    }

    /**
     * Returns the exact number of subsets.
     *
     * @return {@code 2^n}
     */
    public BigInteger sizeExact() {
<span class="nc" id="L225">      return BigInteger.ONE.shiftLeft(n);</span>
    }

    @Override
    public Iterator&lt;int[]&gt; iterator() {
<span class="fc" id="L230">      return new SubsetsIt(n);</span>
    }
  }

  /** Iterable over {@code long} Gray bitmasks, {@code n &lt;= 62}. */
  public static final class AsLongMasks implements Iterable&lt;Long&gt; {
    private final int n;

<span class="fc" id="L238">    private AsLongMasks(int n) {</span>
<span class="fc" id="L239">      this.n = n;</span>
<span class="fc" id="L240">    }</span>

    /**
     * Returns the number of elements in the sequence.
     *
     * @return {@code 2^n}
     */
    public long size() {
      // n &lt;= 62 per validation
<span class="nc" id="L249">      return 1L &lt;&lt; n;</span>
    }

    /**
     * Returns the exact number of elements in the sequence.
     *
     * @return {@code 2^n}
     */
    public BigInteger sizeExact() {
<span class="nc" id="L258">      return BigInteger.ONE.shiftLeft(n);</span>
    }

    @Override
    public Iterator&lt;Long&gt; iterator() {
<span class="fc" id="L263">      return new LongMasksIt(n);</span>
    }
  }

  /** Iterable over {@link BigInteger} Gray bitmasks, any {@code n &gt;= 0}. */
  public static final class AsBigMasks implements Iterable&lt;BigInteger&gt; {
    private final int n;

<span class="fc" id="L271">    private AsBigMasks(int n) {</span>
<span class="fc" id="L272">      this.n = n;</span>
<span class="fc" id="L273">    }</span>

    /**
     * Returns the (possibly saturated) number of elements in the sequence.
     *
     * @return {@code 2^n}, or {@code Long.MAX_VALUE} if the exact value exceeds {@code long}
     */
    public long size() {
<span class="fc" id="L281">      BigInteger s = sizeExact();</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">      return s.bitLength() &lt;= 63 ? s.longValue() : Long.MAX_VALUE;</span>
    }

    /**
     * Returns the exact number of elements in the sequence.
     *
     * @return {@code 2^n}
     */
    public BigInteger sizeExact() {
<span class="fc" id="L291">      return BigInteger.ONE.shiftLeft(n);</span>
    }

    @Override
    public Iterator&lt;BigInteger&gt; iterator() {
<span class="fc" id="L296">      return new BigMasksIt(n);</span>
    }
  }

  /** Iterable over minimal-change toggle events (length {@code 2^n - 1}). */
  public static final class AsToggles implements Iterable&lt;Toggle&gt; {
    private final int n;

<span class="fc" id="L304">    private AsToggles(int n) {</span>
<span class="fc" id="L305">      this.n = n;</span>
<span class="fc" id="L306">    }</span>

    /**
     * Returns the (possibly saturated) number of toggles.
     *
     * @return {@code 2^n - 1}, or {@code Long.MAX_VALUE} if the exact value exceeds {@code long}
     */
    public long size() {
<span class="nc" id="L314">      BigInteger s = sizeExact();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">      return s.bitLength() &lt;= 63 ? s.longValue() : Long.MAX_VALUE;</span>
    }

    /**
     * Returns the exact number of toggles.
     *
     * @return {@code 2^n - 1}
     */
    public BigInteger sizeExact() {
<span class="fc" id="L324">      return BigInteger.ONE.shiftLeft(n).subtract(BigInteger.ONE);</span>
    }

    @Override
    public Iterator&lt;Toggle&gt; iterator() {
<span class="fc" id="L329">      return new TogglesIt(n);</span>
    }
  }

  /**
   * Minimal-change event: bit {@link #index} flipped to {@link #value}.
   *
   * &lt;p&gt;Index {@code 0} refers to the least-significant bit (LSB), matching the numeric masks.
   */
  public static final class Toggle {
    /** Bit position that flipped (0 = least-significant bit). */
    public final int index;

    /** The bit’s new value after the flip: {@code true} for 1, {@code false} for 0. */
    public final boolean value;

    /**
     * Constructs a toggle event.
     *
     * @param index bit index (0..n-1)
     * @param value new bit value after the flip
     */
<span class="fc" id="L351">    public Toggle(int index, boolean value) {</span>
<span class="fc" id="L352">      this.index = index;</span>
<span class="fc" id="L353">      this.value = value;</span>
<span class="fc" id="L354">    }</span>
  }

  // ----------------------------------------------------------------------------------------------
  // Iterators
  // ----------------------------------------------------------------------------------------------

  /** int Gray codes via {@code g = i ^ (i &gt;&gt;&gt; 1)}, {@code i = 0..2^n-1} (n &lt;= 31). */
  private static final class IntsIt implements Iterator&lt;Integer&gt; {
    private final int limit;
<span class="fc" id="L364">    private int i = 0;</span>

<span class="fc" id="L366">    IntsIt(int n) {</span>
<span class="fc" id="L367">      this.limit = 1 &lt;&lt; n;</span>
<span class="fc" id="L368">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L372" title="All 2 branches covered.">      return i &lt; limit;</span>
    }

    @Override
    public Integer next() {
<span class="fc bfc" id="L377" title="All 2 branches covered.">      if (!hasNext()) throw new NoSuchElementException();</span>
<span class="fc" id="L378">      int g = i ^ (i &gt;&gt;&gt; 1);</span>
<span class="fc" id="L379">      i++;</span>
<span class="fc" id="L380">      return Integer.valueOf(g);</span>
    }
  }

  /** long Gray masks via {@code g = i ^ (i &gt;&gt;&gt; 1)}, {@code i = 0..2^n-1} (n &lt;= 62). */
  private static final class LongMasksIt implements Iterator&lt;Long&gt; {
    private final long limit;
<span class="fc" id="L387">    private long i = 0L;</span>

<span class="fc" id="L389">    LongMasksIt(int n) {</span>
<span class="fc" id="L390">      this.limit = 1L &lt;&lt; n; // n&lt;=62</span>
<span class="fc" id="L391">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L395" title="All 2 branches covered.">      return i &lt; limit;</span>
    }

    @Override
    public Long next() {
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">      if (!hasNext()) throw new NoSuchElementException();</span>
<span class="fc" id="L401">      long g = i ^ (i &gt;&gt;&gt; 1);</span>
<span class="fc" id="L402">      i++;</span>
<span class="fc" id="L403">      return Long.valueOf(g);</span>
    }
  }

  /** BigInteger Gray masks via {@code g = i ^ (i &gt;&gt; 1)}, {@code i = 0..2^n-1} (any n). */
  private static final class BigMasksIt implements Iterator&lt;BigInteger&gt; {
    private final BigInteger limit;
<span class="fc" id="L410">    private BigInteger i = BigInteger.ZERO;</span>

<span class="fc" id="L412">    BigMasksIt(int n) {</span>
<span class="fc" id="L413">      this.limit = BigInteger.ONE.shiftLeft(n);</span>
<span class="fc" id="L414">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L418" title="All 2 branches covered.">      return i.compareTo(limit) &lt; 0;</span>
    }

    @Override
    public BigInteger next() {
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">      if (!hasNext()) throw new NoSuchElementException();</span>
<span class="fc" id="L424">      BigInteger g = i.xor(i.shiftRight(1));</span>
<span class="fc" id="L425">      i = i.add(BigInteger.ONE);</span>
<span class="fc" id="L426">      return g;</span>
    }
  }

  /**
   * Bits iterator using the classic “trailing zeros” toggle rule.
   *
   * &lt;p&gt;State starts as all zeros. On step {@code s = 1..2^n-1}, flip bit at {@code r = tz(s)}.
   */
  private static final class BitsIt implements Iterator&lt;int[]&gt; {
    private final int n;
    private final int[] bits; // 0/1, current state
    private final BigInteger limit; // 2^n states
<span class="fc" id="L439">    private BigInteger emitted = BigInteger.ZERO; // states emitted so far</span>

<span class="fc" id="L441">    BitsIt(int n) {</span>
<span class="fc" id="L442">      this.n = n;</span>
<span class="fc" id="L443">      this.bits = new int[n]; // all zeros</span>
<span class="fc" id="L444">      this.limit = BigInteger.ONE.shiftLeft(n);</span>
<span class="fc" id="L445">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L449" title="All 2 branches covered.">      return emitted.compareTo(limit) &lt; 0;</span>
    }

    @Override
    public int[] next() {
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">      if (!hasNext()) throw new NoSuchElementException();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">      if (emitted.signum() == 0) {</span>
<span class="fc" id="L456">        emitted = BigInteger.ONE;</span>
<span class="fc" id="L457">        return Arrays.copyOf(bits, n); // initial zeros</span>
      }
      // flip bit at index = lowest set bit of emitted (the step counter)
<span class="fc" id="L460">      int r = emitted.getLowestSetBit(); // 0..n-1 for s in [1, 2^n-1]</span>
<span class="fc" id="L461">      bits[r] ^= 1;</span>
<span class="fc" id="L462">      emitted = emitted.add(BigInteger.ONE);</span>
<span class="fc" id="L463">      return Arrays.copyOf(bits, n);</span>
    }
  }

  /** Subsets iterator built over BitsIt, mapping 0/1 vectors to sorted index arrays. */
  private static final class SubsetsIt implements Iterator&lt;int[]&gt; {
    private final BitsIt bitsIt;

<span class="fc" id="L471">    SubsetsIt(int n) {</span>
<span class="fc" id="L472">      this.bitsIt = new BitsIt(n);</span>
<span class="fc" id="L473">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc" id="L477">      return bitsIt.hasNext();</span>
    }

    @Override
    public int[] next() {
<span class="fc" id="L482">      int[] b = bitsIt.next();</span>
<span class="fc" id="L483">      int cnt = 0;</span>
<span class="fc bfc" id="L484" title="All 4 branches covered.">      for (int v : b) if (v == 1) cnt++;</span>
<span class="fc" id="L485">      int[] out = new int[cnt];</span>
<span class="fc" id="L486">      int w = 0;</span>
<span class="fc bfc" id="L487" title="All 4 branches covered.">      for (int i = 0; i &lt; b.length; i++) if (b[i] == 1) out[w++] = i;</span>
<span class="fc" id="L488">      return out;</span>
    }
  }

  /**
   * Toggle iterator: emits the minimal-change flip at each step (no initial state element).
   *
   * &lt;p&gt;Yields {@code 2^n - 1} items for {@code n} bits.
   */
  private static final class TogglesIt implements Iterator&lt;Toggle&gt; {
    private final int n;
    private final boolean[] cur; // current bits; we use it only to compute new value
    private final BigInteger limit; // number of states
<span class="fc" id="L501">    private BigInteger s = BigInteger.ONE; // step counter from 1..2^n-1</span>

<span class="fc" id="L503">    TogglesIt(int n) {</span>
<span class="fc" id="L504">      this.n = n;</span>
<span class="fc" id="L505">      this.cur = new boolean[n];</span>
<span class="fc" id="L506">      this.limit = BigInteger.ONE.shiftLeft(n);</span>
<span class="fc" id="L507">    }</span>

    @Override
    public boolean hasNext() {
      // there are (2^n - 1) toggles: s in [1, 2^n-1]
<span class="fc bfc" id="L512" title="All 2 branches covered.">      return s.compareTo(limit) &lt; 0;</span>
    }

    @Override
    public Toggle next() {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">      if (!hasNext()) throw new NoSuchElementException();</span>
<span class="fc" id="L518">      int r = s.getLowestSetBit();</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">      cur[r] = !cur[r];</span>
<span class="fc" id="L520">      Toggle t = new Toggle(r, cur[r]);</span>
<span class="fc" id="L521">      s = s.add(BigInteger.ONE);</span>
<span class="fc" id="L522">      return t;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>